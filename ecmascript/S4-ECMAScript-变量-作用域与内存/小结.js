/**
 * JavaScript 变量可以保存两种数据类型都值：原始值与引用值。
 *  原始值：Undefined，Null，Number，Symbol，String，Boolean
 *  引用值：Object
 * 原始值与引用值有都特点：
 *
 * 原始值大小固定，因此保存在栈内存上。
 * 原始值复制会创建该值的副本。
 * 引用值是对象，存储在堆上。
 * 包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。
 * 引用值复制对象，实际上复制的是指针，因此两个指针指向同一个对象
 * typeof 操作符可以确定是否为原始类型，instanceof 操作符可以确保值的引用类型。
 */

/**
 * 任何变量都存在于某个执行上下文中。这个上下文决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如下。
 * 执行上下文分全局上下文，函数上下文和块级上下文。
 * 代码执行流每进入一个上下文，都会创建一个作用域链，用于搜索变量和函数。
 * 函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文的变量。
 * 全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。
 * 变量的执行上下文用于确定什么时候释放内存。
 */

/**
 * JavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript 的垃圾回收程序可以总结如下。
 * 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。
 * 主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再来回收它们的内存。
 * 引用计数法是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript 引擎不再使用这种算法，
 *      但某些旧版本但 IE 仍然会收到这种算法的影响，原因是 JavaScript 会访问非原生 JavaScript 对象（如 DOM 元素）
 * 引用计数法在代码中存在循环引用时会出现问题。
 * 接触变量的引用不仅可以在消除循环引用，而且对垃圾回收也有帮助。
 *      为促进内存回收，全局对象，全局对象对属性和循环引用都应该在不需要时接触引用。
 */